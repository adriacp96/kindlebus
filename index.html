<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>E-ink SVG Route Map (OSM + OSRM, all-SVG)</title>
  <style>
    html, body { height:100%; margin:0; background:#fff; }
    svg { width:100%; height:100%; display:block; background:#fff; }

    /* e-ink palette */
    .roadMajor { fill:none; stroke:#888; stroke-width:2.2; stroke-linecap:round; stroke-linejoin:round; }
    .roadMinor { fill:none; stroke:#bbb; stroke-width:1.2; stroke-linecap:round; stroke-linejoin:round; }

    .routeOutline { fill:none; stroke:#fff; stroke-width:12; stroke-linecap:round; stroke-linejoin:round; }
    .routeMain    { fill:none; stroke:#000; stroke-width:7;  stroke-linecap:round; stroke-linejoin:round; }

    .stopDot { fill:#fff; stroke:#000; stroke-width:3.5; }
    .stopDot.start { fill:#000; }
    .stopDot.mid   { fill:#fff; }
    .stopDot.end   { fill:#fff; }

    .badge {
      font: 800 18px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      fill:#000;
      paint-order: stroke;
      stroke:#fff;
      stroke-width:6px;
      stroke-linejoin:round;
    }

    .msg {
      font: 700 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      fill:#000;
    }
  </style>
</head>
<body>

<svg id="svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet" aria-label="SVG route map">
  <!-- Everything is drawn in SVG: roads, route, stops -->
  <rect x="0" y="0" width="1200" height="800" fill="#fff"></rect>

  <g id="roads"></g>

  <path id="routeOutline" class="routeOutline" d=""></path>
  <path id="routeMain" class="routeMain" d=""></path>

  <g id="stops"></g>

  <text id="status" class="msg" x="24" y="34">Loading…</text>
</svg>

<script>
/* ======================
   CONFIG (edit if needed)
====================== */
const W = 1200, H = 800;
const PAD = 40; // frame padding inside svg

// Stops from your link (A -> B -> C)
const stops = [
  { name: "Emirates Group HQ", lat: 25.2417461, lng: 55.3659608, badge: "A", kind: "start" },
  { name: "Pink Building",    lat: 25.2097705, lng: 55.2731029, badge: "B", kind: "mid"   },
  { name: "Grosvenor",        lat: 25.2231508, lng: 55.2801991, badge: "C", kind: "end"   }
];

// OSRM route (open/free)
const OSRM_PROFILE = "driving"; // driving | walking | cycling
const OSRM_URL = "https://router.project-osrm.org/route/v1/";

// Overpass API for OSM roads (open/free)
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

// How much map area to fetch around route (in degrees approx; works fine at Dubai scale)
const BBOX_PAD_DEG = 0.01;

// Road filters (OSM highway tags)
const MAJOR = new Set(["motorway","trunk","primary","secondary","tertiary"]);
const MINOR = new Set(["unclassified","residential","service","living_street","road"]);

/* ======================
   SVG helpers
====================== */
const svg = document.getElementById("svg");
const gRoads = document.getElementById("roads");
const gStops = document.getElementById("stops");
const statusEl = document.getElementById("status");
const routeOutline = document.getElementById("routeOutline");
const routeMain = document.getElementById("routeMain");

function setStatus(t){ statusEl.textContent = t; }

function el(name, attrs = {}) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", name);
  for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
  return n;
}

/* ======================
   Projection (Web Mercator)
   We map lon/lat -> mercator -> fit to SVG
====================== */
function mercX(lng){ return (lng + 180) / 360; }
function mercY(lat){
  const rad = lat * Math.PI / 180;
  const a = Math.log(Math.tan(Math.PI/4 + rad/2));
  return (1 - a / Math.PI) / 2;
}

function boundsFromLatLng(points){
  let minLat=  90, maxLat= -90, minLng= 180, maxLng=-180;
  for (const p of points){
    minLat = Math.min(minLat, p.lat);
    maxLat = Math.max(maxLat, p.lat);
    minLng = Math.min(minLng, p.lng);
    maxLng = Math.max(maxLng, p.lng);
  }
  return { minLat, maxLat, minLng, maxLng };
}

function makeProjector(bounds){
  // Expand bounds
  const b = {
    minLat: bounds.minLat - BBOX_PAD_DEG,
    maxLat: bounds.maxLat + BBOX_PAD_DEG,
    minLng: bounds.minLng - BBOX_PAD_DEG,
    maxLng: bounds.maxLng + BBOX_PAD_DEG
  };

  // Convert to mercator space (note: mercY decreases as lat increases)
  const x1 = mercX(b.minLng), x2 = mercX(b.maxLng);
  const y1 = mercY(b.maxLat), y2 = mercY(b.minLat);

  const sx = (W - 2*PAD) / (x2 - x1);
  const sy = (H - 2*PAD) / (y2 - y1);
  const s = Math.min(sx, sy);

  // Centering
  const mapW = (x2 - x1) * s;
  const mapH = (y2 - y1) * s;
  const ox = (W - mapW)/2 - x1*s;
  const oy = (H - mapH)/2 - y1*s;

  return function project(lng, lat){
    const x = mercX(lng) * s + ox;
    const y = mercY(lat) * s + oy;
    return { x, y };
  };
}

function pointsToPathD(pts){
  if (!pts.length) return "";
  let d = \`M \${pts[0].x.toFixed(1)} \${pts[0].y.toFixed(1)}\`;
  for (let i=1;i<pts.length;i++){
    d += \` L \${pts[i].x.toFixed(1)} \${pts[i].y.toFixed(1)}\`;
  }
  return d;
}

/* ======================
   Fetch route from OSRM (exact geometry)
====================== */
async function fetchRoute() {
  const coords = stops.map(s => \`\${s.lng},\${s.lat}\`).join(";");
  const url = \`\${OSRM_URL}\${OSRM_PROFILE}/\${coords}?overview=full&geometries=geojson&steps=false\`;
  const res = await fetch(url, { cache: "no-store" });
  const data = await res.json();
  const r = data.routes?.[0];
  if (!r?.geometry?.coordinates?.length) throw new Error("OSRM: no route");
  // return as [{lat,lng}, ...]
  return r.geometry.coordinates.map(([lng,lat]) => ({ lat, lng }));
}

/* ======================
   Fetch roads from Overpass in bbox
====================== */
async function fetchRoads(bbox){
  // bbox order for Overpass: (south,west,north,east)
  const south = bbox.minLat - BBOX_PAD_DEG;
  const west  = bbox.minLng - BBOX_PAD_DEG;
  const north = bbox.maxLat + BBOX_PAD_DEG;
  const east  = bbox.maxLng + BBOX_PAD_DEG;

  const query = \`
[out:json][timeout:25];
(
  way["highway"](\${south},\${west},\${north},\${east});
);
out body;
>;
out skel qt;
  \`.trim();

  const res = await fetch(OVERPASS_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
    body: "data=" + encodeURIComponent(query)
  });

  const data = await res.json();

  const nodes = new Map();
  const ways = [];

  for (const el of data.elements){
    if (el.type === "node") nodes.set(el.id, { lat: el.lat, lng: el.lon });
    if (el.type === "way") ways.push(el);
  }

  // Convert ways to polylines with coords
  const polylines = [];
  for (const w of ways){
    const hw = w.tags?.highway || "";
    const kind = MAJOR.has(hw) ? "major" : (MINOR.has(hw) ? "minor" : "minor");

    const pts = [];
    for (const nid of (w.nodes || [])){
      const n = nodes.get(nid);
      if (n) pts.push(n);
    }
    if (pts.length >= 2) polylines.push({ kind, pts });
  }
  return polylines;
}

/* ======================
   Render
====================== */
function renderRoads(roadPolylines, project){
  gRoads.innerHTML = "";

  // draw minor first, then major on top
  const sorted = roadPolylines.slice().sort((a,b) => (a.kind === "major") - (b.kind === "major"));
  for (const r of sorted){
    const pts = r.pts.map(p => project(p.lng, p.lat));
    const d = pointsToPathD(pts);
    const path = el("path", {
      d,
      class: r.kind === "major" ? "roadMajor" : "roadMinor"
    });
    gRoads.appendChild(path);
  }
}

function renderRoute(routePoints, project){
  const pts = routePoints.map(p => project(p.lng, p.lat));
  const d = pointsToPathD(pts);
  routeOutline.setAttribute("d", d);
  routeMain.setAttribute("d", d);
}

function renderStops(project){
  gStops.innerHTML = "";
  for (const s of stops){
    const p = project(s.lng, s.lat);

    const c = el("circle", {
      cx: p.x, cy: p.y, r: 10,
      class: \`stopDot \${s.kind}\`
    });
    gStops.appendChild(c);

    const t = el("text", {
      x: p.x + 14,
      y: p.y + 6,
      class: "badge"
    });
    t.textContent = s.badge;
    gStops.appendChild(t);
  }
}

/* ======================
   Main
====================== */
(async function main(){
  try{
    setStatus("Loading route…");
    const route = await fetchRoute();

    // bounds based on route (better than stops only)
    const b = boundsFromLatLng(route);
    const project = makeProjector(b);

    setStatus("Loading roads…");
    const roads = await fetchRoads(b);

    setStatus("Rendering…");
    renderRoads(roads, project);
    renderRoute(route, project);
    renderStops(project);

    setStatus(""); // hide text
  } catch (e){
    setStatus("Failed: " + (e?.message || e));
  }
})();
</script>
</body>
</html>
